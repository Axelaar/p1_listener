#!/usr/bin/python3
#
# Analyze the standard P1 telegram to define 
# length of required datafields.
# Run this script to generate the telegram definitions
# to be used by the 'p1_listener.py' script.
#
# Place a text file with a complete single P1 telegram
# in directory /home/pi/dsmr/.
# Default text file name is 'standard_telegram.txt'.
# Generate this file by executing 'p1_telegram_discovery.py'.
#
# This script evaluates only the obis codes that are
# included in the obis code listing below.
# The obis code is the key, the value is the variable
# name to be used in the 'p1_listener.py' script.
#
# Created by Bram Langen - Mar 5, 2020.
# v1.41 - Corrected the dsmr directory path.

import os;
import re;
import sys;

############################################################
# Initialize / declare variables
############################################################
filename_in             = '/home/pi/dsmr/standard_telegram.txt';
filename_out            = '/home/pi/dsmr/telegram_definition.txt';
obis_count              = 0;

############################################################
# Define data_object class.
# This class is used to link the obis code to the variable
# name in plain text as it is used in 'p1_listener.py'.
# The last two fields are left blank, they are reserved for
# the websocket identifier and the IP Telegram identifier.
############################################################
class data_object:
    def __init__(self, obis, long_text, IP_id, ws_id):
        self.obis       = obis;
        self.long_text  = long_text;
        self.IP_id      = IP_id;
        self.ws_id      = ws_id;

############################################################
# Populate the desired obis codes listing.
# Comment out the obis code lines that you do not want
# to monitor.
# The long text value represents the variable name as used 
# in the monitoring script.
#
#                **********IMPORTANT:**********
# '1-3:0.2.8': 'dsmr_version' is a required entry.
#
############################################################
object_list = [];# This is a required statement.
object_list.append(data_object('1-3:0.2.8', 'dsmr_version', '', ''));# This is a required entry.
object_list.append(data_object('1-0:1.8.1', 'kwh_total_in_tariff1', '', ''));
object_list.append(data_object('1-0:1.8.2', 'kwh_total_in_tariff2', '', ''));
object_list.append(data_object('1-0:2.8.1', 'kwh_total_out_tariff1', '', ''));
object_list.append(data_object('1-0:2.8.2', 'kwh_total_out_tariff2', '', ''));
object_list.append(data_object('1-0:1.7.0', 'kw_actual_in', '', ''));
object_list.append(data_object('1-0:2.7.0', 'kw_actual_out', '', ''));
object_list.append(data_object('0-0:96.14.0', 'tariff', '', ''));
object_list.append(data_object('0-1:24.2.1', 'gas', '', ''));
object_list.append(data_object('1-0:21.7.0', 'kw_actual_in_A', '', ''));
object_list.append(data_object('1-0:41.7.0', 'kw_actual_in_B', '', ''));
object_list.append(data_object('1-0:61.7.0', 'kw_actual_in_C', '', ''));
object_list.append(data_object('1-0:22.7.0', 'kw_actual_out_A', '', ''));
object_list.append(data_object('1-0:42.7.0', 'kw_actual_out_B', '', ''));
object_list.append(data_object('1-0:62.7.0', 'kw_actual_out_C', '', ''));

############################################################
# Verify directory dsmr exists
############################################################
if not os.path.isdir('/home/pi/dsmr'):
    os.mkdir('home/pi/dsmr');
    print ('Directory "dsmr" created.');

############################################################
# Read the file with the complete telegram as transmitted
# by the smart meter.  For each matching line, write an 
# entry in the definitions file with the specifics for
# each data object.
############################################################
if os.path.isfile(filename_in):
    print (filename_in , 'found.');
    f_read  = open(filename_in, 'r');
    f_write = open(filename_out, 'w');
    f_write.write('# This file is generated by ' + sys.argv[0] + '\r\n');
    while True:
        input_line = f_read.readline();
        if input_line[0:1] == '!':
            # The last line of the telegram is the CRC value, preceded by an exclamation mark.
            break
        # enumerate returns a tuple where the first value is the index number, and the second
        # value the original value of the list.
        for index, object in enumerate(object_list):
            if object.obis in input_line:
                if input_line[2] == '0':
                    # The channel number is '0' for the electricity meter, and a higher number for the gas meter.
                    stripped_line = re.sub(r'[a-zA-Z*]', '', input_line);
                    starting_position = stripped_line.find('(') +1;
                    ending_position = stripped_line.find(')');
                else:
                    stripped_line = input_line.replace('*m3', '');
                    starting_position = stripped_line.find('(') +1;
                    ending_position = stripped_line.find(')', -2);     # search for the ending bracket only.
                f_write.write(object.obis + ';' + str(starting_position) + ';' + \
                    str(ending_position) + ';' + object.long_text + ';' + \
                    object.IP_id + ';' + object.ws_id + ';\r\n');
                obis_count += 1;
    f_read.close();
    f_write.close();
    print ('Script completed succesfully, converted %d obis codes.' % obis_count);
else:
    print ('Error: ' + filename_in + ' not found');
exit()