#!/usr/bin/python3
#
# Obtain actual energy consumption.
# This script relies on two text files:
#  A file containing a standard telegram;
#  A file containing the obis definitions;
# The obis definitions in the file define which values will be
# read from the smart meter.
# The location of these files is specified in the config file.
# 
# The definitions file is generated by running script 
# /home/pi/dsmr/dsmr_definition.py.
#
# Configuration settings are taken from /home/pi/p1_listener.conf.
#
# Created by Bram Langen - Mar 3, 2020
# version 3.15 - Removed the path for the logfile.

from    os.path                    import isfile;
import  serial;
import  sys;
from    time                       import sleep;
# Add the local library to the default path listing.
sys.path.insert(0, '/home/pi/local_lib');
from    local_lib.custom_functions import *;

############################################################
# Obtain the logfile and config file names based on the
# name of the script.
# sys.argv[0] is the script path and file name
############################################################
path, logfile, configfile = generate_filenames(sys.argv[0]);

############################################################
# Set default variables.  These values can be overridden
# by the configuration settings.
############################################################
target_timezone         = 'Europe/Amsterdam';
logsettings             = logfile, target_timezone;
timer_IP                = 300;
timer_rrd               = 300;
timer_ws                = 300;

############################################################
# Obtain the variables from the configuration file,
# and take necessary update, import and declare actions.
############################################################
if isfile(configfile):
    f = open(configfile, 'r');
    while True:
        raw_line = f.readline();
        if raw_line[0:16] == '! End of listing' or raw_line == '':
            break;
        elif raw_line[0] != '#':
            command = raw_line.replace('\r', '').replace('\n', '');
            if command != '':
                try:
                    exec(command);
                except:
                    write_log_entry('a', 'Error in config line %s, script halted.' % command, logsettings);
                    f.close();
                    exit(0);
    f.close();
    # Update the logsettings values based on the data in the config file.
    logsettings = logfile, target_timezone;
    if use_IP_telegram:
        try:                # Test to see if the host for sending IP telegrams has been populated.
            host;
        except:             # If the entry does not exist, then halt the script.
            write_log_entry('a', 'Incomplete IP address information, script halted.', logsettings);
            exit(0);
        from local_lib.IP_transmit import *;
        UDPSock_error   = False;
    if use_ws_telegram:
        try:                # Test to see if the required websocket information has been populated.
            ws_connection_detail;
        except:             # If the entry does not exist, then halt the script.
            write_log_entry('a', 'Missing websocket connection information, script halted.', logsettings);
            exit(0);
        from local_lib.ws_transmit import *;
    if use_rrd:
        try:                # Test to see if the required rrd information has been populated.
            rrddb_e;
            rrddb_g;
        except:             # If the entries do not exist, then halt the script.
            write_log_entry('a', 'Missing database name, script halted.', logsettings);
            exit(0);
        from local_lib.update_rrd import *;
        write_log   = True;
    if not use_IP_telegram and not use_rrd and not use_ws_telegram:
        write_log_entry('a', 'Nothing to send, script halted.', logsettings);
        exit(0);
else:
    write_log_entry('a', 'Config file not found.', logsettings);
    exit();

############################################################
# Define data_object class.
# This class is used to link the obis code to the variable,
# and to the transmission identifiers for websocket and IP.
# Variable is the variable name as used in this script to
# refer to an obis code in normal text.  For instance, 
# obis code '1-0:1.8.1' becomes 'kwh_total_in_tariff1' in 
# the calculations in this script.
# ws_id is the 5-character code used as identifier in the 
# websocket transmissions, i.e. 'L__In' for obis code '1-0:1.8.1'
############################################################
class data_object:
    def __init__(self, obis, starting_position, ending_position, variable, IP_id, ws_id):
        self.obis = obis;
        self.starting_position  = starting_position;
        self.ending_position    = ending_position;
        self.variable           = variable;
        self.IP_id              = IP_id;
        self.ws_id              = ws_id;

############################################################
# Populate the attributes of the objects by
# reading the object definitions file.
# Set each variable to 'None'.
# Declare a companion 'previous' variable for each object
# entry, and set it to 'None' as well.
# Any error in this section will terminate the script.
############################################################
if isfile(object_definitions):
    try:
        f_read = open(object_definitions, 'r');
        object_list = [];           # List contains all definitions per object
        obis_list   = [];           # List contains only the obis identifiers
        while True:
            input_line = f_read.readline();
            if input_line == '':
                break;
            elif (delimiter in input_line and input_line[:9] != '1-3:0.2.8'):
                # The 'and' statement in this 'elif' skips the dsmr version line.
                defs = input_line.split(delimiter);
                # Data object attributes are: obis, starting_position, ending_position, variablename 
                # and the two placeholders for the IP and ws identifiers.
                object_list.append(data_object(defs[0], defs[1], defs[2], defs[3], defs[4], defs[5]));
                obis_list.append(defs[0]);
                # Now set the variable and 'previous variable' to 'None'
                exec('%s = %s = None' % (defs[3], 'previous_' + defs[3]));
    except:
        message = 'Fout bij het inlezen van de object definities, script gestopt.';
        write_log_entry('a', message, logsettings);
        sys.exit (message);
    f_read.close();
else:
    message = 'Object definitiebestand niet gevonden, script gestopt.';
    write_log_entry('a', message, logsettings);
    sys.exit (message);

############################################################
# Find and assign the indexes of the kWh_total obis codes.
############################################################
index_list = [];
for obis in obis_list:
    if obis   == '1-0:1.8.1':
        index_1_8_1 = obis_list.index(obis);
        index_list.append(index_1_8_1);
    elif obis == '1-0:1.8.2':
        index_1_8_2 = obis_list.index(obis);
        index_list.append(index_1_8_2);
    elif obis == '1-0:2.8.1':
        index_2_8_1 = obis_list.index(obis);
        index_list.append(index_2_8_1);
    elif obis == '1-0:2.8.2':
        index_2_8_2 = obis_list.index(obis);
        index_list.append(index_2_8_2);

############################################################
# Set the IP identifiers if IP telegrams are used.
# The list is declared by default, as it is used
# further on in the script.
############################################################
IP_obis_list = [];
if use_IP_telegram:
    for i in range(len(IP_object_list)):
        IP_obis = IP_object_list[i][0];
        IP_obis_list.append(IP_obis);
        for obis in obis_list:
            if obis == IP_obis:
                index = obis_list.index(obis);
                object_list[index].IP_id = IP_object_list[i][1],IP_object_list[i][2];
    ############################################################
    # Determine which kWh totals must be transmitted, if any.
    ############################################################
    IP_kWh_counters_index_list = [];
    for index in index_list:
        if obis_list[index] in IP_obis_list:
            IP_kWh_counters_index_list.append(index);
    if len(IP_kWh_counters_index_list) > 0:
        transmit_IP_counters = True;
    else:
        transmit_IP_counters = False;

############################################################
# Set the websocket identifiers if websocket is used.
# The list is declared by default, as it is used
# further on in the script.
############################################################
ws_obis_list = [];
if use_ws_telegram:
    for ws_obis in ws_object_list:
        ws_obis_list.append(ws_obis[0]);
        for obis in obis_list:
            if obis == ws_obis[0]:
                index = obis_list.index(obis);
                object_list[index].ws_id = ws_obis[1];
    ############################################################
    # Determine which kWh totals must be transmitted, if any.
    ############################################################
    ws_kWh_counters_index_list = [];
    for index in index_list:
        if obis_list[index] in ws_obis_list:
            ws_kWh_counters_index_list.append(index);
    if len(ws_kWh_counters_index_list) > 0:
        transmit_ws_counters = True;
    else:
        transmit_ws_counters = False;

############################################################
# Obtain the dsmr version from the standard telegram file.
############################################################
if isfile(standard_telegram):
    try:
        f_read = open(standard_telegram, 'r');
        while True:
            input_line = f_read.readline();
            if input_line == '':
                break;
            elif input_line[:9] == '1-3:0.2.8':
                index = input_line.find('(');
                dsmr_version = input_line[index+1];
                break;
    except:
        message = 'Fout bij het inlezen van de dsmr versie, script gestopt.';
        write_log_entry('a', message, logsettings);
        sys.exit (message);
    f_read.close();
else:
    message = 'Standaard telegrambestand niet gevonden, script gestopt.';
    write_log_entry('a', message, logsettings);
    sys.exit (message);

############################################################
# Set COM port config depending on dsmr version
############################################################
ser                 = serial.Serial();
ser.port            = p1_usb_port;
ser.timeout         = 20;
if dsmr_version == '3':
    ser.baudrate    = 9600;
    ser.bytesize    = serial.SEVENBITS;
    ser.parity      = serial.PARITY_EVEN;
    ser.stopbits    = serial.STOPBITS_ONE;
    ser.xonxoff     = 1;
    ser.rtscts      = 0;#              # Enable hardware (RTS/CTS) flow control.
elif dsmr_version > '3':
    ser.baudrate    = 115200;
    ser.bytesize    = serial.EIGHTBITS;
    ser.parity      = serial.PARITY_NONE;
    ser.stopbits    = serial.STOPBITS_ONE;
    ser.xonxoff     = 1;
    ser.rtscts      = 0;

#############################################################
# Initialize variables
############################################################
counter_IP                  = 250;
counter_rrd                 = 250;
counter_ws                  = -2;
data_is_good                = False;
do_daily_log                = True;
error_msg                   = '';
found_p1_telegram_start     = False;
log_e                       = True;
log_g                       = True;
midnight                    = False;
new_gas_reading             = False;
p1_telegram_complete        = False;
serial_port_is_open         = False;
ts_gas = previous_ts_gas    = None;

############################################################
#
# Main script starts here
#
############################################################
write_log_entry('a', 'Script %s successfully started.' % sys.argv[0], logsettings);

###########################################################
# Open COM port, if it fails then abort the script.
# Start the perpetual loop
############################################################
while True:
    if not serial_port_is_open:
        try:
            ser.open();
            write_log_entry('a', ('Seriele poort %s geopend.' % ser.name), logsettings);
            serial_port_is_open = True;
        except:
            message = 'Fout bij het openen van poort %s.  Script beeindigd.' % ser.name;
            write_log_entry('a', message, logsettings);
            sys.exit (message);

    ############################################################
    # Receive a data transmission line 
    ############################################################
    try:
        p1_raw = ser.readline();                                        # readline() returns bytes, not text!
    except:
        write_log_entry('a', ('Fout bij het lezen van poort %s, poort wordt gesloten. ' % ser.name ), logsettings);
        ser.close();
        serial_port_is_open = False;
        sleep(15);
    ##############################################################
    # Only execute the rest of the code if the port is open and
    # hence a transmission could have been received.
    ##############################################################
    try:
        if serial_port_is_open:
            p1_line = bytes.decode(p1_raw, errors='ignore').strip();    # Ignore errors - they occur when the p1
            data_is_good = True;                                        # cable has been disconnected and then reconnected.
    except:
        write_log_entry('a', ('Fout bij het decoderen van de data, poort %s wordt gesloten. ' % ser.name ), logsettings);
        ser.close();
        serial_port_is_open = False;
        data_is_good = False;
        sleep(15);
    if data_is_good:
        ##########################################################
        # When the script first starts up, the received line of
        # transmitted data may be in the middle of a telegram set. 
        # This means some variables may still be 'None', causing
        # incomplete data.
        # Only start the interpretation of data once the opening
        # telegram line has been received.  The first character
        # of (only) that line is '/'.
        ##########################################################
        if not found_p1_telegram_start:
            try:
                if p1_line[0] == '/':
                    found_p1_telegram_start = True;
            except:
                pass;
        elif found_p1_telegram_start:
            ##########################################################
            # Interpret the received line of transmitted data.
            # The data lines start with the obis code, followed by 
            # the transmitted data.  When a matching code is found, assign
            # the data value to the variable linked to the obis code as 
            # defined in the data_object dataset.
            ##########################################################
            if not p1_telegram_complete:
                try:
                    if p1_line[0:1] == '!':                     # end of a complete transmission reached
                        p1_telegram_complete = True;
                except:
                    pass;
            try:
                if data_is_good:
                    if (p1_line[0:1] == "/"):                   # This signals the first line of a telegram set.
                        if dsmr_version > '4':                  # It is used to increment the time counters.
                                counter_IP  += 1;               # dsmr version 5 and higher sends every second.
                                counter_ws  += 1;
                                counter_rrd += 1;
                        else:                                   # up to dsmr version 4 telegrams are sent every 10 seconds.
                                counter_IP  += 10;              # add the 10-second tick to the counters
                                counter_ws  += 10;
                                counter_rrd += 10;
                    for obis in obis_list:
                        if obis in p1_line:
                            index = obis_list.index(obis);
                            if obis[2] == '0':
                                # Electricity data is listed on channel '0', which is
                                # the third character (=index '2') of the obis code.
                                # Gas data is typically listed on channel '1'.
                                value = float(p1_line[int(object_list[index].starting_position):int(object_list[index].ending_position)]);
                                if 'kW' in p1_line:
                                    exec('%s = %f' % (object_list[index].variable, value));
                                else:
                                    exec('%s = %d' % (object_list[index].variable, value));
                            else:
                                ts_gas = p1_line[int(object_list[index].starting_position):p1_line.find(')')];
                                if ts_gas != previous_ts_gas:
                                    previous_ts_gas = ts_gas;
                                    new_gas_reading = True;
                                    value = float(p1_line[p1_line.find(')(') + 2 :int(object_list[index].ending_position)]);
                                    exec('%s = %f' % (object_list[index].variable, value));
                            break;
            except:
                write_log_entry('a', 'Fout bij het decoderen van de telegramregels.', logsettings);
        if p1_telegram_complete:
            ##########################################################
            #
            # Now do something with the received data - send it to the
            # receiver(s) as defined in the configuration file.
            # 
            ##########################################################
            ##########################################################
            # Which variables are to be used is defined in the config 
            # file, they will be part of the IP_obis_list
            # or ws_obis_list or both.
            #
            # Each received line of transmitted data is evaluated here
            # to see if it matches an obis code in an obis list.
            # 
            # For each change in tariff or power in/out, send 
            # an IP and/ or ws transmission.
            # Send the Electricity counter totals only when the timer 
            # reaches the setpoint.
            # Send the gas counter total only when a new timestamp 
            # has been received.
            ##########################################################
            addr = object_list[index].IP_id;
            if '0-0:96.14.0' == object_list[index].obis:
                # This is the tariff indicator
                if tariff != previous_tariff:
                    previous_tariff = tariff;
                    if '0-0:96.14.0' in IP_obis_list:
                        UDPSock_error, error_msg = IP_transmit(addr, str(tariff), UDPSock_error);
                    if '0-0:96.14.0' in ws_obis_list:
                        ws_transmit(ws_connection_detail, object_list[index].ws_id, tariff, delimiter);
            elif '1-0:1.7.0' == object_list[index].obis:
                # This is the actual power in, in kW.
                if kw_actual_in != previous_kw_actual_in:
                    previous_kw_actual_in = kw_actual_in;
                    if '1-0:1.7.0' in IP_obis_list:
                        UDPSock_error, error_msg = IP_transmit(addr, str(kw_actual_in), UDPSock_error);
                    if '1-0:1.7.0' in ws_obis_list:
                        ws_transmit(ws_connection_detail, object_list[index].ws_id, kw_actual_in, delimiter);
            elif '1-0:2.7.0' == object_list[index].obis:
                # This is the actual power out, in kW.
                if kw_actual_out != previous_kw_actual_out:
                    previous_kw_actual_out = kw_actual_out;
                    if '1-0:2.7.0' in IP_obis_list:
                        UDPSock_error, error_msg = IP_transmit(addr, str(kw_actual_out), UDPSock_error);
                    if '1-0:2.7.0' in ws_obis_list:
                        ws_transmit(ws_connection_detail, object_list[index].ws_id, kw_actual_out, delimiter);
            elif '1-0:21.7.0' == object_list[index].obis:
                # This is the actual power in for phase A, in kW.
                if kw_actual_in_A != previous_kw_actual_in_A:
                    previous_kw_actual_in_A = kw_actual_in_A;
                    if '1-0:21.7.0' in IP_obis_list:
                        UDPSock_error, error_msg = IP_transmit(addr, str(kw_actual_in_A), UDPSock_error);
                    if '1-0:21.7.0' in ws_obis_list:
                        ws_transmit(ws_connection_detail, object_list[index].ws_id, kw_actual_in_A, delimiter);
            elif '1-0:41.7.0' == object_list[index].obis:
                # This is the actual power for phase B, in kW.
                if kw_actual_in_B != previous_kw_actual_in_B:
                    previous_kw_actual_in_B = kw_actual_in_B;
                    if '1-0:41.7.0' in IP_obis_list:
                        UDPSock_error, error_msg = IP_transmit(addr, str(kw_actual_in_B), UDPSock_error);
                    if '1-0:41.7.0' in ws_obis_list:
                        ws_transmit(ws_connection_detail, object_list[index].ws_id, kw_actual_in_B, delimiter);
            elif '1-0:61.7.0' == object_list[index].obis:
                # This is the actual power for phase C, in kW.
                if kw_actual_in_C != previous_kw_actual_in_C:
                    previous_kw_actual_in_C = kw_actual_in_C;
                    if '1-0:61.7.0' in IP_obis_list:
                        UDPSock_error, error_msg = IP_transmit(addr, str(kw_actual_in_C), UDPSock_error);
                    if '1-0:61.7.0' in ws_obis_list:
                        ws_transmit(ws_connection_detail, object_list[index].ws_id, kw_actual_in_C, delimiter);
            elif '1-0:22.7.0' == object_list[index].obis:
                # This is the actual power out for phase A, in kW.
                if kw_actual_out_A != previous_kw_actual_out_A:
                    previous_kw_actual_out_A = kw_actual_out_A;
                    if '1-0:22.7.0' in IP_obis_list:
                        UDPSock_error, error_msg = IP_transmit(addr, str(kw_actual_out_A), UDPSock_error);
                    if '1-0:22.7.0' in ws_obis_list:
                        ws_transmit(ws_connection_detail, object_list[index].ws_id, kw_actual_out_A, delimiter);
            elif '1-0:42.7.0' == object_list[index].obis:
                # This is the actual power for phase B, in kW.
                if kw_actual_out_B != previous_kw_actual_out_B:
                    previous_kw_actual_out_B = kw_actual_out_B;
                    if '1-0:42.7.0' in IP_obis_list:
                        UDPSock_error, error_msg = IP_transmit(addr, str(kw_actual_out_B), UDPSock_error);
                    if '1-0:42.7.0' in ws_obis_list:
                        ws_transmit(ws_connection_detail, object_list[index].ws_id, kw_actual_out_B, delimiter);
            elif '1-0:62.7.0' == object_list[index].obis:
                # This is the actual power for phase C, in kW.
                if kw_actual_out_C != previous_kw_actual_out_C:
                    previous_kw_actual_out_C = kw_actual_out_C;
                    if '1-0:62.7.0' in IP_obis_list:
                        UDPSock_error, error_msg = IP_transmit(addr, str(kw_actual_out_C), UDPSock_error);
                    if '1-0:62.7.0' in ws_obis_list:
                        ws_transmit(ws_connection_detail, object_list[index].ws_id, kw_actual_out_C, delimiter);
            elif '0-1:24.2.1' == object_list[index].obis:
                if new_gas_reading:
                    if '0-1:24.2.1' in IP_obis_list:
                        UDPSock_error, error_msg = IP_transmit(addr, str(gas), UDPSock_error);
                        counter_IP = timer_IP + 1;
                    if '0-1:24.2.1' in ws_obis_list:
                        ws_transmit(ws_connection_detail, object_list[index].ws_id, gas, delimiter);
                        counter_ws = timer_ws + 1;
            if error_msg != '':
                write_log_entry('a', error_msg, logsettings);
            if use_IP_telegram and counter_IP > timer_IP and transmit_IP_counters:
                # When the preset time has been reached, send the kWh_total counter data,
                # and reset the counter (timer).
                for index in IP_kWh_counters_index_list:
                    exec('counter_value = %s' % object_list[index].variable);
                    IP_transmit(object_list[index].IP_id, str(counter_value), UDPSock_error);
                counter_IP = -2;
            if use_ws_telegram and counter_ws > timer_ws and transmit_ws_counters:
                # When the preset time has been reached, send the kWh_total counter data,
                # and reset the counter (timer).
                for index in ws_kWh_counters_index_list:
                    exec('kWh_value = %s' % object_list[index].variable);
                    ws_transmit(ws_connection_detail, object_list[index].ws_id, kWh_value, delimiter);
                counter_ws = -2;
            ##########################################################
            if use_rrd:
                if counter_rrd > timer_rrd:                 # Update the electricity db each time interval as
                    #                                       # defined in the config file.
                    if 'rrddb_e' in locals():               # Test to see if the electricity db has been assigned.
                        ##########################################################
                        # Which variables are to be used is defined in the config 
                        # file, they will be part of the rrd_object_list.
                        ##########################################################
                        data = [];
                        for rrd_obis in rrd_object_list:
                            for obis in obis_list:
                                if obis == rrd_obis:
                                    index = obis_list.index(obis);
                                    break;
                            exec('data.append(%s)' % object_list[index].variable);
                        # Multiply each kW value in the tuple by 1000 and convert to an integer,
                        # and write the converted values to the database.
                        log_e = rrd_trigger(rrddb_e, tuple(int(i * 1000) for i in data), 
                            log_e, logsettings);
                        # Multiply the gasmeter reading by 1000, convert to an integer, and write to the database.
                if 'rrddb_g' in locals():               # Test to see if the gas db has been assigned.
                    if new_gas_reading:                 # Only write to the db when a new gas counter transmission has arrived
                        log_g = rrd_trigger(rrddb_g, int(gas * 1000), log_g, logsettings);
            new_gas_reading = False;
            if counter_rrd > timer_rrd:
                counter_rrd = 0;
            ##########################################################
            # Add the counter totals to the daily log file,if this
            # option has been set in the config file.
            ##########################################################
            if 'daily_counter_logfile' in locals():
                timestamp = get_time(target_timezone);
                if   timestamp[11:16] == "00:00":
                    midnight        = True;
                elif timestamp[11:16] == '00:01':
                    midnight        = False;
                    do_daily_log    = True;         # Reset the trigger to write the daily log
                try:
                    if midnight and do_daily_log:   # Send the data to the log file once per day
                        f=open(daily_counter_logfile, 'a');
                        f.write (timestamp);
                        f.write (delimiter);
                        for log_object in log_object_list:
                            for obis in obis_list:
                                if obis == log_object:
                                    index = obis_list.index(obis);
                                    break;
                            exec('f.write (str(%s))' % object_list[index].variable);
                            f.write (delimiter);
                        f.write (log_list_clarification_text);
                        f.close();
                        do_daily_log = False;
                except:
                    write_log_entry('a', ('Fout bij het schrijven naar bestand %s. ' % daily_counter_logfile, logsettings ));
    sleep(60);
exit(0)